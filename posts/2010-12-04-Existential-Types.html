<!DOCTYPE HTML>
<html><head><title>Functorial Blog - Existential Types in C#</title><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,300|Roboto:400,700|Roboto+Condensed:400,700"><link rel="stylesheet" type="text/css" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"><link rel="stylesheet" type="text/css" href="../assets/default.css"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="text/javascript" src="../assets/gaq.js"></script></head><body><div id="container"><h1 class="text-center">Functorial Blog</h1><p class="lead text-center">A blog about functional programming</p><p class="text-center"><a href="../index.html">Home</a></p></div><section class="dark"><div class="container"><h2>Existential Types in C#</h2><p><small>by Phil Freeman on 2010/12/04</small></p><p>I was thinking about existential types recently, what they might be useful for, and if it was possible to encode them in C#.</p>
<p>First, a quick recap. A value of an existential type <code>exists X. T</code> looks like a pair consisting of a type <code>A</code> and a value <code>a</code> of type <code>T[X\A]</code> which is the result of substituting the type <code>A</code> for the bound type variable <code>X</code> in <code>T</code>. This creates a notion of information hiding where the interface being defined is given by the type expression <code>T</code>, and the implementation is hidden in the type <code>A</code> and the term <code>a</code> which the developer can only access by unpacking the existential package.</p>
<p>As an example, think of the situation where we want to assign unique identifiers to a set of objects. For our purposes, we don&#39;t care what the actual representation of the identifiers will be, so long as they uniquely identify the objects in question. We would need two functions: a way of creating a new identifier, and a way of mapping an existing identifier to the object it uniquely identifies.</p>
<p>We might encode this as follows:</p>
<pre><code>interface KeyProvider&lt;K, T&gt; 
{
    K NextKey(T t);

    T Map(K key);
}
</code></pre>
<p>Here, the type variable <code>K</code> stands for the type of the identifiers, the type we want to hide. The type variable <code>T</code> denotes the type of object we hope to uniquely identify.</p>
<p>We might create an implementation using the <code>System.Guid</code> class or by using a counter, but the user should not be able to get at the underlying type.</p>
<p>Fortunately, there is a nice isomorphism</p>
<blockquote>
<p>exists X. T = forall R. (forall X. T -&gt; R) -&gt; R</p>
</blockquote>
<p>Basically, this says that if you want a value of any type, R, say, and you can compute it given an existential package with any underlying type X, then I can give you that value by instantiating your generic function with the underlying type of the existential package and applying it to its payload.</p>
<p>The isomorphism looks like</p>
<blockquote>
<p>pack A a =&gt; \R. \f. f[A] a</p>
</blockquote>
<p>We can unpack the type by providing a result type R and passing in a function of type <code>forall X. T -&gt; R</code></p>
<p>Translating this into C# using generics for universals we get:</p>
<pre><code>interface KeyProviderFunction&lt;R, T&gt;
{
    R Apply&lt;K&gt;(KeyProvider&lt;K, T&gt; provider);
}

interface KeyProvider&lt;T&gt;
{
    R Apply&lt;R, T&gt;(KeyProviderFunction&lt;R, T&gt; f);
}
</code></pre>
<p>With this kind of method dispatch, we&#39;ve created a version of the KeyProvider interface with the type variable K hidden.</p>
<p>Now, to use an implementation of KeyProvider<T>, we simply have to provide a function of type KeyProviderFunction&lt;R, T&gt; for some result type R.</p>
<h2>Peano Arithmetic</h2>
<p>Here&#39;s an example encoding Peano arithmetic over a hidden data type.</p>
<p>An algebra for the Peano axioms is a type with a zero, and a successor function. For illustration purposes, we&#39;ll also add a printing function ToString:</p>
<pre><code>interface PeanoArithmetic&lt;T&gt;
{
    T Zero { get; }

    T Successor(T t);

    string ToString(T t);
}
</code></pre>
<p>Now we can existentially quantify over the type parameter T to define a Peano algebra with a hidden underlying type:</p>
<pre><code>interface PeanoArithmeticFunction&lt;R&gt;
{
     R Apply&lt;T&gt;(PeanoArithmetic&lt;T&gt; arithmetic);
}
 
interface PeanoArithmetic
{
     R Apply&lt;R&gt;(PeanoArithmeticFunction&lt;R&gt; f);
}
</code></pre>
<p>Here is a simple implementation using Integers as the underlying type:</p>
<pre><code>class PeanoArithmeticImplementation : PeanoArithmetic
{
    class PeanoArithmeticMethods : PeanoArithmetic&lt;int&gt;
    {
         public int Zero
         {
             get { return 0; }
         }
 
         public int Successor(int n)
         {
             return n + 1;
         }
 
         public string ToString(int n)
         {
             return n.ToString();
         }
    }

    public R Apply&lt;R&gt;(PeanoArithmeticFunction&lt;R&gt; f)
    {
         return f.Apply&lt;int&gt;(new PeanoArithmeticMethods());
    }
}
</code></pre>
<p>Even though the type parameter has been hidden, the existentially quantified type can still be used. We can, for example, print the numbers 1, 2, 3 as follows:</p>
<pre><code>class Program
{
     class OneTwoThree : PeanoArithmeticFunction&lt;string&gt;
     {
         public string Apply&lt;T&gt;(PeanoArithmetic&lt;T&gt; a)
         {
             var _0 = a.Zero;
             var _1 = a.Successor(_0);
             var _2 = a.Successor(_1);
             var _3 = a.Successor(_2);
             
             return string.Format(&quot;{0}, {1}, {2}&quot;,
                 a.ToString(_1),
                 a.ToString(_2),
                 a.ToString(_3));
         }
     }

     static void Main(string[] args)
     {
         PeanoArithmetic peano = new PeanoArithmeticImplementation();
         Console.WriteLine(peano.Apply&lt;string&gt;(new OneTwoThree()));
     }
}
</code></pre>
</div></section><div class="container"><p class="text-center text-muted"><small>Copyright Phil Freeman 2010-2015</small></p></div></body></html>