<!DOCTYPE HTML>
<html><head><title>Functorial Blog - Counterexamples of Type Classes</title><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Roboto+Slab:300"><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Roboto+Mono:300"><link rel="stylesheet" type="text/css" href="../assets/default.css"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="text/javascript" src="../assets/gaq.js"></script></head><body><header><h1>Counterexamples of Type Classes</h1><p>by Phil Freeman on 2015/12/06</p><hr></header><main><p>In Haskell and PureScript, we are familiar with certain standard hierarchies of type classes. For example, here are some of the type classes provided by the PureScript core libraries:</p>
<ul>
<li><code>Semigroup</code>, <code>Monoid</code></li>
<li><code>Semiring</code>, <code>Ring</code>, <code>CommutativeRing</code>, <code>EuclideanRing</code>, <code>Field</code></li>
<li><code>Functor</code>, <code>Apply</code>, <code>Applicative</code>, <code>Bind</code>, <code>Monad</code></li>
<li><code>Extend</code>, <code>Comonad</code></li>
<li><code>Alt</code>, <code>Plus</code>, <code>Alternative</code></li>
<li><code>Semigroupoid</code>, <code>Category</code></li>
<li><code>Profunctor</code>, <code>Strong</code>, <code>Arrow</code></li>
</ul>
<p>For each of these hierarchies, we have examples of each class, and in many cases, free constructions for superclass relationships.</p>
<p>However, it is also instructive to look at <em>counterexamples</em>, of types which inhabit a superclass, but not a subclass, to understand why these refinements are useful.</p>
<h2>The Monoid Hierarchy</h2>
<p>The <code>Monoid</code> type class from Haskell is refined in PureScript, by splitting out the <code>append</code> operation into the <code>Semigroup</code> class:</p>
<pre class="text"><code>class Semigroup m where
  append :: m -&gt; m -&gt; m

class (Semigroup m) &lt;= Monoid m where
  mempty :: m
</code></pre>
<h3>A Semigroup which is not a Monoid</h3>
<p>Non-empty lists form a <code>Semigroup</code>, where <code>append</code> is given by concatenating two lists:</p>
<pre class="text"><code>data NonEmpty a = NonEmpty a (List a)
</code></pre>
<p>In fact, <code>NonEmpty a</code> is the <em>free semigroup</em> for the type <code>a</code>.</p>
<h3>Notes on Semigroup</h3>
<p>In general, structures which lack empty elements might have instances of <code>Semigroup</code> but not of <code>Monoid</code>.</p>
<p>The free construction of a <code>Monoid</code> from a <code>Semigroup</code> is to simply add an empty element:</p>
<pre class="text"><code>data FreeMonoid s = Empty | NonEmpty s

instance freeMonoidFromSemigroup :: (Semigroup s) =&gt; Monoid (FreeMonoid s)
</code></pre>
<p>The two free constructions <code>NonEmpty</code> and <code>FreeMonoid</code> compose to give something isomorphic to <code>List a</code>, the free <code>Monoid</code> for the type <code>a</code>.</p>
<p>An example of an operation which typically uses a <code>Monoid</code> instance, but which only <em>requires</em> a <code>Semigroup</code> is Haskell&#39;s <code>foldl1</code> from <code>Data.List</code>. Since we are always folding at least one element, we only need an <code>append</code> operation, not an empty element.</p>
<pre class="text"><code>foldl1 :: forall s. (Semigroup s) =&gt; NonEmpty s -&gt; s
</code></pre>
<p>The applicative validation functor provides an example of a data structure which can be generalized to work with any Semigroup:</p>
<pre class="text"><code>data Validation s a = Validation (Either s a)

instance (Semigroup s) =&gt; Applicative (Validation s)
</code></pre>
<p>Here, we can use the <code>append</code> operation to collect multiple errors, but we do not require a full <code>Monoid</code>. For example, <code>Validation (NonEmpty String)</code> might be used to collect a non-empty list of validation errors represented as strings.</p>
<p><code>Validation</code> is <em>not</em> a <code>Monad</code>, unlike <code>Either</code>, since there is no implementation of <code>&gt;&gt;=</code> which is compatible with the <code>Applicative</code> implementation.</p>
<h2>The Field Hierarchy</h2>
<p>The <code>Field</code> type class from Haskell is refined into a number of type classes in PureScript:</p>
<pre class="text"><code>class Semiring a where
  add  :: a -&gt; a -&gt; a
  zero :: a
  mul  :: a -&gt; a -&gt; a
  one  :: a

class Semiring a &lt;= Ring a where
  sub :: a -&gt; a -&gt; a

class Ring a &lt;= CommutativeRing a where

class CommutativeRing a &lt;= EuclideanRing a where
  div :: a -&gt; a -&gt; a
  mod :: a -&gt; a -&gt; a
  degree :: a -&gt; Int

class Ring a &lt;= DivisionRing a where
  recip :: a -&gt; a

class EuclideanRing a &lt;= Field a
</code></pre>
<p>The <code>Semiring</code> class specifies the addition and multiplication operations, while subtraction is split into the <code>Ring</code> class.</p>
<p>Commutative rings are specified by the <code>CommutativeRing</code> class.</p>
<p>Division and the modulus operator are broken into the <code>EuclideanRing</code> class.</p>
<p><code>DivisionRing</code> specifies an alternative to division in terms of a reciprocal function, and requires that <code>recip</code> provides multiplicative inverses. A <code>DivisionRing</code> need not be commutative.</p>
<p>Finally, <code>Field</code> requires that multiplication is commutative.</p>
<h3>A Semiring which is not a Ring</h3>
<p>Natural numbers form a <code>Semiring</code>, but do not form a <code>Ring</code>, since they lack additive inverses:</p>
<pre class="text"><code>data Nat = Zero | Succ Nat
</code></pre>
<h3>A Ring which is not a DivisionRing</h3>
<p>The integers provide an example of a <code>Ring</code> which is not a <code>DivisionRing</code>, since non-zero integers do not have multiplicative inverses.</p>
<p>The integers are also an example of a <code>EuclideanRing</code> which is not a <code>Field</code>.</p>
<h3>A CommutativeRing which is not a EuclideanRing</h3>
<p>Number theory provides examples of commutative rings which fail to be Euclidean. For example, rings which are not principal ideal domains cannot be Euclidean.</p>
<p>Wikipedia provides <a href="https://en.wikipedia.org/wiki/Euclidean_domain#Examples">some additional counterexamples</a>.</p>
<h3>A DivisionRing which is not a CommutativeRing</h3>
<p>The quaternions are an example of a structure with multiplicative inverses but non-commutative multiplication. They form a <code>DivisionRing</code>, but not a <code>CommutativeRing</code>.</p>
<h3>Notes on Semiring</h3>
<p>There is a free <code>Semiring</code> which can be constructed from any base type, formed by using distributivity to represent terms in &quot;<code>+</code>-normal form&quot;:</p>
<pre class="text"><code>data FreeSemiring a = FreeSemiring (List (List a))

instance freeSemiring :: Semiring (FreeSemiring a)
</code></pre>
<p>This type is implemented in the <code>purescript-semirings</code> library.</p>
<p>The free semiring may be interpreted in any semiring:</p>
<pre class="text"><code>liftFree :: forall s a. (Semiring s) =&gt; (a -&gt; s) -&gt; Free a -&gt; s
</code></pre>
<p>giving a form of abstract interpretation of the semiring operations.</p>
<p>Here are two examples of data structures which can be usefully generalized to work with an arbitrary <code>Semiring</code>:</p>
<ul>
<li>The familiar probability monad <code>newtype Prob a = Prob (List (Tuple Number a))</code> can be generalized to use a <code>Semiring</code> of probabilities: <code>data GProb s a = GProb (List (Tuple s a))</code>. Choosing different <code>Semiring</code>s recovers other less-familiar monads such as a monad for describing quantum wavefunctions (take <code>s</code> to be the Semiring of complex numbers) and a monad for managing priority queues (take <code>s</code> to be the (<code>Max</code>, <code>+</code>) Semiring).</li>
<li>The applicative validation functor has an <code>Alternative</code> instance for collecting errors in parallel whenever the errors form a Semiring.</li>
</ul>
<h2>Notes on Ring</h2>
<p>We can construct a <code>Ring</code> from any <code>Semiring</code> in the same way as we construct the integers from the naturals, by representing <em>differences</em>:</p>
<pre class="text"><code>data Diff a = Diff a a

instance Semiring a =&gt; Ring (Diff a)
</code></pre>
<p>We identify any two values of type <code>Diff a</code> which represent the same difference.</p>
<h2>Notes on DivisionRing</h2>
<p>We can formally add divisors to any <code>Ring</code> in much the same way:</p>
<pre class="text"><code>data Ratio a = Ratio a a

instance Ring a =&gt; DivisionRing (Ratio a)
</code></pre>
<p>We disallow zero divisors, and identify any two values of type <code>Ratio a</code> which represent the same ratio.</p>
<h2>The Monad Hierarchy</h2>
<p>Haskell&#39;s <code>Monad</code> hierarchy is further refined in PureScript, by the addition of the <code>Apply</code> class which contains the <code>&lt;*&gt;</code> operator (but not <code>pure</code>) and the <code>Bind</code> class which specifies the <code>&gt;&gt;=</code> operator:</p>
<pre class="text"><code>class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b

class Functor f &lt;= Apply f where
  apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b

class Apply f &lt;= Applicative f where
  pure :: forall a. a -&gt; f a

class Apply m &lt;= Bind m where
  bind :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b

class (Applicative m, Bind m) &lt;= Monad m
</code></pre>
<h3>A type constructor which is not a Functor</h3>
<p>Functor forces the type variable of its argument to appear covariantly, so a simple example of a type constructor which is not a Functor is given by:</p>
<pre class="text"><code>data Op a b = Op (b -&gt; a)
</code></pre>
<p><code>Op</code> can be made into a contravariant functor, described by the <code>Contravariant</code> type class, which we will not cover here.</p>
<h3>A Functor which is not an Apply</h3>
<p>There is a functor for any type constructor, given by the Yoneda lemma:</p>
<pre class="text"><code>newtype Yoneda f a = Yoneda (forall r. (a -&gt; r) -&gt; f r)
</code></pre>
<p><code>Yoneda f</code> is always a <code>Functor</code>, but cannot be made into an instance of <code>Apply</code> in general, since to implement <code>&lt;*&gt;</code>, we would require a function of type:</p>
<pre class="text"><code>forall a b r. (forall r. ((a -&gt; b) -&gt; r) -&gt; f r) -&gt;
              (forall r. (a        -&gt; r) -&gt; f r) -&gt;
                         (b        -&gt; r) -&gt; f r
</code></pre>
<h3>An Apply which is not an Applicative</h3>
<p>The constant functor</p>
<pre class="text"><code>data Const k a = Const k
</code></pre>
<p>can be made into an <code>Apply</code> (but not an <code>Applicative</code>) whenever <code>k</code> is an instance of <code>Semigroup</code> (but not <code>Monoid</code>).</p>
<h3>An Applicative which is not a Monad</h3>
<p>We have already seen that the validation functor is an example of an <code>Applicative</code> which is not a <code>Monad</code>, and therefore also an example of an <code>Apply</code> which is not a <code>Bind</code>.</p>
<p>Another example is given by the <code>ZipList</code> functor, where <code>apply</code> is implemented using <code>zipWith</code>:</p>
<pre class="haskell"><code>newtype ZipList a = ZipList (List a)
</code></pre>
<h3>A Bind which is not a Monad</h3>
<p>The <code>Map</code>k data type has an implementation of <code>Bind</code>, since we can implement the <code>map</code>, <code>apply</code> and <code>bind</code> functions, but fails to be a <code>Monad</code>, since we cannot implement</p>
<pre class="text"><code>pure :: forall k a. a -&gt; Map k a
</code></pre>
<p>such that the monad laws will hold.</p>
<h3>Notes on Apply</h3>
<p><code>Apply</code> is enough to implement a variant of <code>zip</code>:</p>
<pre class="text"><code>zipA :: forall f a b. (Apply f) =&gt; f a -&gt; f b -&gt; f (Tuple a b)
</code></pre>
<p>where we can recover the original <code>zip</code> function by using the <code>ZipList</code> applicative.</p>
<h3>Notes on Bind</h3>
<p><code>Bind</code> is enough to implement Kleisli composition:</p>
<pre class="text"><code>(&gt;=&gt;) :: forall f a b c. (Bind f) =&gt; (a -&gt; f b) -&gt; (b -&gt; f c) -&gt; a -&gt; f c
</code></pre>
<h2>The Comonad Hierarchy</h2>
<p>PureScript refines the <code>Comonad</code> type class to extract the <code>extend</code> function into its own <code>Extend</code> class:</p>
<pre class="text"><code>class Functor w &lt;= Extend w where
  extend :: forall b a. (w a -&gt; b) -&gt; w a -&gt; w b

class Extend w &lt;= Comonad w where
  extract :: forall a. w a -&gt; a
</code></pre>
<h3>An Extend which is not a Comonad</h3>
<p>The function type gives an example of a <code>Comonad</code> whenever the domain is monoidal. If we relax the constraint to <code>Semigroup</code>, however, we only obtain an <code>Extend</code>:</p>
<pre class="text"><code>instance extendFn :: Semigroup w =&gt; Extend ((-&gt;) w)
</code></pre>
<p>For example, the <code>NonEmpty Unit</code> semigroup can be thought of as non-zero natural numbers, and gives us an <code>Extend</code> instance which allows us to reannotate a semi-infinite tape by considering values (strictly) to the right of the current position.</p>
<h3>Notes on Extend</h3>
<p><code>Extend</code> is enough to implement co-Kleisli composition:</p>
<pre class="text"><code>(=&gt;=) :: forall b a w c. (Extend w) =&gt; (w a -&gt; b) -&gt; (w b -&gt; c) -&gt; w a -&gt; c
</code></pre>
<h2>The Alternative Hierarchy</h2>
<p>In PureScript, the <code>Alternative</code> class is refined so that the alternation operator <code>&lt;|&gt;</code> is broken out into the <code>Alt</code> class, the <code>empty</code> structure is defined by the <code>Plus</code> class, and <code>Alternative</code> is redefined as a combination of <code>Applicative</code> and <code>Plus</code>:</p>
<pre class="text"><code>class Functor f &lt;= Alt f where
  alt :: forall a. f a -&gt; f a -&gt; f a

class Alt f &lt;= Plus f where
  empty :: forall a. f a

class (Applicative f, Plus f) &lt;= Alternative f
</code></pre>
<h3>An Alt which is not a Plus</h3>
<p><code>NonEmpty</code> is an example of an <code>Alt</code> in which <code>alt</code> is given by concatenation, but there is no <code>Plus</code> instance due to the lack of an empty element.</p>
<h3>A Plus which is not an Alternative</h3>
<p><code>Map k</code> is an example of a <code>Plus</code> which is not <code>Alternative</code>, due to the lack of an <code>Applicative</code> instance</p>
<h3>Notes on Alt</h3>
<p><code>Alt</code> is enough to define <code>oneOf1</code>, a variant on <code>oneOf</code> which requires at least one alternative:</p>
<pre class="text"><code>oneOf1 :: forall f a. (Alt f) =&gt; NonEmpty (f a) -&gt; f a
</code></pre>
<p>Any <code>Alt</code> can be used to construct a <code>Semigroup</code> (but not necessarily a <code>Monoid</code>) using <code>&lt;|&gt;</code>.</p>
<h3>Notes on Plus</h3>
<p><code>Plus</code> is enough to define <code>oneOf</code>:</p>
<pre class="text"><code>oneOf :: forall f a. (Plus f) =&gt; List (f a) -&gt; f a
</code></pre>
<h2>The Category Hierarchy</h2>
<p>In PureScript, the <code>Category</code> type class is refined by splitting the <code>compose</code> operation into the <code>Semigroupoid</code> class:</p>
<pre class="text"><code>class Semigroupoid a where
  compose :: forall b c d. a c d -&gt; a b c -&gt; a b d

class Semigroupoid a &lt;= Category a where
  id :: forall t. a t t
</code></pre>
<h3>A Semigroupoid which is not a Category</h3>
<p><code>Tuple</code> is an example of a <code>Semigroupoid</code> which is not a <code>Category</code>. We can think of <code>Tuple</code> as a strange function space in which we identify only a single point in the domain and a single point in the codomain.</p>
<p>In the same vein, another example is given by</p>
<pre class="text"><code>newtype Relation a b = Relation (List (Tuple a b))
</code></pre>
<p>in which we choose a selection of pairs of points from the domain and codomain. Again, there is no <code>Category</code> instance, since we cannot construct</p>
<pre><code>id :: forall a. Relation a a
</code></pre>
<p>in general, unless both the domain and codomain are enumerable.</p>
<p>Kleisli arrows form a <code>Semigroupoid</code> whenever <code>f</code> is a <code>Bind</code>, but not a <code>Category</code> in general, unless <code>f</code> is also a <code>Monad</code>:</p>
<pre class="text"><code>newtype Kleisli f a b = Kleisli (a -&gt; f b)
newtype Cokleisli f a b = Cokleisli (f a -&gt; b)
</code></pre>
<p>A similar construction creates a <code>Semigroupoid</code> on <code>Cokleisli f</code> whenever <code>f</code> has <code>Extend</code> (but not necessarily <code>Comonad</code>).</p>
<p>Static arrows <code>f (a -&gt; b)</code> form a <code>Semigroupoid</code> whenever <code>f</code> is an <code>Apply</code>, but not a <code>Category</code> in general, unless <code>f</code> is also <code>Applicative</code>:</p>
<pre class="text"><code>newtype Static f a b = Static (f (a -&gt; b))
</code></pre>
<h3>Notes on Semigroupoid</h3>
<p>Any <code>Semigroupoid</code> supports the composition of a <code>NonEmpty</code> list of morphisms:</p>
<pre class="text"><code>compose1 :: forall s a. (Semigroupoid s) =&gt; NonEmpty (s a a) -&gt; s a a
</code></pre>
<h2>The Arrow Hierarchy</h2>
<p>In PureScript, the <code>Arrow</code> type class is defined in terms of a combination of <code>Category</code> and strong profunctors:</p>
<pre class="text"><code>class Profunctor p where
  dimap :: forall a b c d. (a -&gt; b) -&gt; (c -&gt; d) -&gt; p b c -&gt; p a d

class Profunctor p &lt;= Strong p where
  first :: forall a b c. p a b -&gt; p (Tuple a c) (Tuple b c)

class (Category a, Strong a) &lt;= Arrow a
</code></pre>
<h3>A Profunctor which is not Strong</h3>
<p>Here is a <code>Profunctor</code> which ignores its first type argument, so parametericity makes it impossible to define <code>first</code>:</p>
<pre class="text"><code>newtype Ignore a b = Ignore b
</code></pre>
<h3>A Strong Profunctor which is not an Arrow</h3>
<p><code>Kleisli f</code> is <code>Strong</code> whenever <code>f</code> is a <code>Functor</code>, but cannot be an <code>Arrow</code> unless <code>f</code> is a <code>Monad</code>, due to the lack of a <code>Category</code> instance.</p>
<h3>A Category which is not an Arrow</h3>
<p>Isomorphisms form a <code>Category</code>:</p>
<pre class="text"><code>data Iso a b = Iso { to :: a -&gt; b, from :: b -&gt; a }
</code></pre>
<p>But <code>Iso</code> cannot be a <code>Profunctor</code> since <code>a</code> appears both covariantly and contravariantly.</p>
<h3>Notes on Profunctor</h3>
<p>A <code>Profunctor</code> supports a change of types using any <em>isomorphism</em>:</p>
<pre class="text"><code>data Iso s a = Iso { to :: s -&gt; a, from :: a -&gt; s }

liftIso :: forall p a s. (Profunctor p) =&gt; Iso s a -&gt; p a a -&gt; p s s
</code></pre>
<h3>Notes on Strong</h3>
<p>A <code>Strong</code> profunctor supports a focussing operation using any <em>lens</em>:</p>
<pre class="text"><code>data Lens s a = Lens { get :: s -&gt; a, set :: s -&gt; a -&gt; s }

liftLens :: forall p a s. (Strong p) =&gt; Lens s a -&gt; p a a -&gt; p s s
</code></pre>
</main><footer><hr><p class="text-muted"><small>Â© Phil Freeman 2010-2018</small></p></footer></body></html>