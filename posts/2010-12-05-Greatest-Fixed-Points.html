<!DOCTYPE HTML>
<html><head><title>functorial.com - Greatest Fixed Points and Anamorphisms in C#</title><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Lato:300,400,700"><link rel="stylesheet" type="text/css" href="../css/default.css"><meta name="viewport" content="width=device-width, initial-scale=1.0"><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-33896432-1']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script></head><body><div id="header"><div class="centered"><h1><a href="../index.html" style="text-decoration: none; color: white;">functorial</a></h1><p>Type Theory and Programming Languages Blog</p></div><div id="splitter"></div></div><div class="centered"><div id="navigation"><a href="../index.html">Home</a>&nbsp;<a href="../feed.xml">RSS Feed</a></div><h2>Greatest Fixed Points and Anamorphisms in C#</h2><p><small>by Phil Freeman on 2010/12/05</small></p><hr><p>As promised in my last post, I'm now going to go over how to encode greatest fixed point types and their anamorphisms in C# using existentials.</p>
<p>A recap: we use the isomorphisms</p>
<blockquote>
<p>exists X. T ~ forall R. (forall X. T -&gt; R) -&gt; R</p>
<p>\(pack X x). \R. \f. f x</p>
</blockquote>
<p>and</p>
<blockquote>
<p>Nu F ~ exists X. X * (X -&gt; F X)</p>
<p>\x. pack x out</p>
</blockquote>
<p>where the second morphism has an inverse given by</p>
<blockquote>
<p>\(pack X x). \f. ana f x</p>
</blockquote>
<p>where <code>ana f</code> denotes the anamorphism generated by <code>f</code>.</p>
<p>As an example, we are going to treat the case of infinite streams over an alphabet A:</p>
<blockquote>
<p>Stream A := Nu (\X. A * X)</p>
</blockquote>
<p>Let's first interpret the second isomorphism above in this context. We have</p>
<blockquote>
<p>Stream A ~ exists X. X * (X -&gt; X * A)</p>
</blockquote>
<p>The packed type here acts as an indicator of the position in the stream. We could take <code>X = int</code>. For constant streams, we could even let <code>X = ()</code>, the unit type. Then, we can interpret the existential package <code>pack X a f</code> as the stream with first few elements <code>a</code>, <code>outr (f a)</code>, <code>outr f (outr (f a))</code>, ...</p>
<p>Let's translate this into C#. First, our definition of a stream, using the first isomorphism above to encode existentials as universals:</p>
<pre><code>struct StreamF&lt;A, T&gt;
{
    public T Seed { get; set; }
    public Func&lt;T, Tuple&lt;T, A&gt;&gt; Generator { get; set; }
}

interface StreamFunction&lt;A, R&gt;
{
    R Apply&lt;T&gt;(StreamF&lt;A, T&gt; n);
}

interface Stream&lt;A&gt;
{
    R Apply&lt;R&gt;(StreamFunction&lt;A, R&gt; f);
}</code></pre>
<p>With that definition, we can proceed to define anamorphisms in the way one would expect:</p>
<pre><code>class AnaStream&lt;A, T&gt; : Stream&lt;A&gt;
{
    private readonly StreamF&lt;A, T&gt; sf;


    public AnaStream(StreamF&lt;A, T&gt; sf)
    {
        this.sf = sf;
    }

    public R Apply&lt;R&gt;(StreamFunction&lt;A, R&gt; f)
    {
        return f.Apply&lt;T&gt;(sf);
    }
}

public static Func&lt;T, Stream&lt;A&gt;&gt; Ana&lt;A, T&gt;(Func&lt;T, Tuple&lt;T, A&gt;&gt; generator)
{
    return seed =&gt; new AnaStream&lt;A, T&gt;(new StreamF&lt;A, T&gt;
    {
        Seed = seed,
        Generator = generator
    });
}</code></pre>
<p>With anamorphisms under our belt, we can now define constant streams with ease:</p>
<pre><code>public static Stream&lt;T&gt; Const&lt;T&gt;(T t)
{
    return Ana&lt;T, Unit&gt;(u =&gt; Tuple.Create&lt;Unit, T&gt;(u, t))(new Unit());
}</code></pre>
<p>with <code>Unit</code> here denoting any one-point type.</p>
<p>Consing an element onto the front of a stream is a little tricky. The idea is to replace the underlying type of the existential package T with the type <code>Maybe T := 1 + T</code>. Here the unit type corresponds to the head of the new stream and the T corresponds to the tail. In order to get at the underlying type of the package, we have to wrap any <code>StreamFunction&lt;A&gt;</code> object which will be responsible for unpacking the existential package:</p>
<pre><code>class ConsFunction&lt;A, R&gt; : StreamFunction&lt;A, R&gt;
{
    private A head;
    private StreamFunction&lt;A, R&gt; tailFunction;

    public ConsFunction(StreamFunction&lt;A, R&gt; tailFunction, A head)
    {
        this.head = head;
        this.tailFunction = tailFunction;
    }

    public R Apply&lt;T&gt;(StreamF&lt;A, T&gt; n)
    {

        return tailFunction.Apply&lt;Either&lt;Unit, T&gt;&gt;(new StreamF&lt;A, Either&lt;Unit, T&gt;&gt;
        {
            Seed = Either&lt;Unit, T&gt;.inl(new Unit()),
            Generator = pair =&gt; pair.Case(
                u =&gt; Tuple.Create&lt;Either&lt;Unit, T&gt;, A&gt;(
                    Either&lt;Unit, T&gt;.inr(n.Seed), head),
                new Func&lt;T, Tuple&lt;Either&lt;Unit, T&gt;, A&gt;&gt;(t =&gt;
                {
                    Tuple&lt;T, A&gt; next = n.Generator(t);
                    return Tuple.Create&lt;Either&lt;Unit, T&gt;, A&gt;(
                        Either&lt;Unit, T&gt;.inr(next.Item1), next.Item2);
                }))
        });
    }
}

class ConsStream&lt;A&gt; : Stream&lt;A&gt;
{
    private Stream&lt;A&gt; tail;
    private A head;

    public ConsStream(Stream&lt;A&gt; tail, A head)
    {
        this.tail = tail;
        this.head = head;
    }

    public R Apply&lt;R&gt;(StreamFunction&lt;A, R&gt; tailFunction)
    {
        return tail.Apply(new ConsFunction&lt;A, R&gt;(tailFunction, head));
    }
}

public static Stream&lt;A&gt; Cons&lt;A&gt;(this Stream&lt;A&gt; s, A a)
{
    return new ConsStream&lt;A&gt;(s, a);
}</code></pre>
<p>Here, the Either class is used to represent sum types. It has two constructors and a generic method used to destruct its values:</p>
<pre><code>class Either&lt;A, B&gt;
{
    private bool flag;
    private A a;
    private B b;

    private Either() { }

    public static Either&lt;A, B&gt; inl(A value)
    {
        return new Either&lt;A, B&gt;
        {
            flag = true,
            a = value
        };
    }

    public static Either&lt;A, B&gt; inr(B value)
    {
        return new Either&lt;A, B&gt;
        {
            flag = false,
            b = value
        };
    }

    public T Case&lt;T&gt;(Func&lt;A, T&gt; aFunc, Func&lt;B, T&gt; bFunc)
    {
        return flag ? aFunc(a) : bFunc(b);
    }
}</code></pre>
<p>To take an element from the head of a stream, we can use the same generator function, but shift the seed value by one iteration:</p>
<pre><code>class NextStream&lt;A, T&gt; : Stream&lt;A&gt;
{
    private Stream&lt;A&gt; s;
    private StreamF&lt;A, T&gt; n;

    public NextStream(Stream&lt;A&gt; s, StreamF&lt;A, T&gt; n)
    {
        this.s = s;
        this.n = n;
    }

    public R Apply&lt;R&gt;(StreamFunction&lt;A, R&gt; f)
    {
        return f.Apply&lt;T&gt;(new StreamF&lt;A, T&gt;
        {
            Seed = n.Generator(n.Seed).Item1,
            Generator = n.Generator
        });
    }
}

class NextFunction&lt;A&gt; : StreamFunction&lt;A, Tuple&lt;A, Stream&lt;A&gt;&gt;&gt;
{
    private Stream&lt;A&gt; s;

    public NextFunction(Stream&lt;A&gt; s)
    {
        this.s = s;
    }

    public Tuple&lt;A, Stream&lt;A&gt;&gt; Apply&lt;T&gt;(StreamF&lt;A, T&gt; n)
    {
        return Tuple.Create&lt;A, Stream&lt;A&gt;&gt;(n.Generator(n.Seed).Item2,
            new NextStream&lt;A, T&gt;(s, n));
    }
}

public static Tuple&lt;A, Stream&lt;A&gt;&gt; Next&lt;A&gt;(this Stream&lt;A&gt; s)
{
    return s.Apply&lt;Tuple&lt;A, Stream&lt;A&gt;&gt;&gt;(new NextFunction&lt;A&gt;(s));
}</code></pre>
<p>Next time I plan to give a treatment of another greatest fixed point type - the conatural numbers - and their arithmetic.</p>
<hr><div id="disqus_thread"><script type="text/javascript">var disqus_shortname = 'functorial';
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></body></html>