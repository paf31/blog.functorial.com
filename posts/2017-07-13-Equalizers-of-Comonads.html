<!DOCTYPE HTML>
<html><head><title>Functorial Blog - Equalizers of Comonads</title><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Roboto+Slab:300"><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Roboto+Mono:300"><link rel="stylesheet" type="text/css" href="../assets/default.css"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="text/javascript" src="../assets/gaq.js"></script></head><body><header><h1>Equalizers of Comonads</h1><p>by Phil Freeman on 2017/07/13</p><hr></header><main><p>Here&#39;s an interesting little result:</p>
<blockquote>
<p>Consider a comonad <code>w</code> which preserves limits, and suppose we have a natural transformation <code>f :: w ~&gt; I</code> where <code>I</code> is the identity functor.</p>
<p>Note that <code>extend f</code> is also a natural transformation <code>w ~&gt; w</code>.</p>
<p>When the equalizer <code>q ~&gt; w</code> of <code>extend f</code> and <code>id</code> exists, it also has a comonadic structure, induced by the one on <code>w</code>.</p>
</blockquote>
<p>Before seeing the proof, let&#39;s consider what this means for the comonads as spaces approach to user interfaces.</p>
<h2>Example</h2>
<p>Take <code>w</code> to be a cofree comonad generated by the functor</p>
<pre class="purescript"><code>data Step a = Step a a
</code></pre>
<p>The dual functor</p>
<pre class="purescript"><code>data Action a = L a | R a
</code></pre>
<p>defines a free monad which pairs with <code>w</code>. The actions</p>
<pre class="purescript"><code>left, right :: Free Action Unit
left = liftFree (L unit)
right = liftFree (R unit)
</code></pre>
<p>combine to give two &quot;loops&quot; <code>left *&gt; right</code> and <code>right *&gt; left</code>. These loops pair to give natural transformations <code>w ~&gt; w</code>.</p>
<p>We can form the equalizer which makes these loops equal to the identity, and we can think of the resulting comonad as a zipper which is infinite in both directions.</p>
<p>In practice, this means that we can work with the original comonad <code>w</code> if it is more convenient, as long as our actions equalize the appropriate morphisms, so that we stay inside the equalizer.</p>
<h2>Proof (Sketch)</h2>
<p>Suppose the equalizer <code>phi :: q ~&gt; w</code> exists.</p>
<p>Consider the natural transformation <code>duplicate . phi :: q ~&gt; w^2</code>. We have</p>
<pre><code>extend f . duplicate . phi
= map f . duplicate . duplicate . phi
{- naturality -}
= duplicate . map f . duplicate . phi
= duplicate . extend f . phi
{- phi equalizes extend f and id -}
= duplicate . phi
</code></pre>
<p>So <code>duplicate . phi</code> equalizes <code>extend f</code> and <code>id</code>. Therefore it factors through the equalizer, and we have <code>gamma :: q ~&gt; w q</code> such that <code>map phi . gamma = duplicate . phi</code>.</p>
<p>Now, since <code>w</code> preserves limits, we have that <code>wq</code> is the equalizer of <code>map (extend f)</code> and <code>id</code>. <code>gamma</code> factors through this equalizer (to see this, consider composition on the left with <code>map phi</code>, which is mono), and so induces <code>alpha :: q -&gt; q^2</code> such that <code>phi . alpha = gamma</code>.</p>
<p>The claim is that <code>alpha</code> gives a comonad structure on <code>q</code>, together with <code>extract</code> given by <code>extract . phi</code>.</p>
<p>To see this, observe that <code>map phi . phi . alpha = duplicate . phi</code>, and that <code>phi</code> is a mono. The comonad laws for <code>duplicate</code> pull back to the equivalent laws for <code>alpha</code> via the mono <code>phi</code>.</p>
<p>QED</p>
</main><footer><hr><p class="text-muted"><small>Â© Phil Freeman 2010-2021</small></p></footer></body></html>