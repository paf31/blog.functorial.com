<!DOCTYPE HTML>
<html><head><title>Functorial Blog - Stackless Coroutines in PureScript</title><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,300|Roboto:400,700|Roboto+Condensed:400,700"><link rel="stylesheet" type="text/css" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"><link rel="stylesheet" type="text/css" href="../assets/default.css"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="text/javascript" src="../assets/gaq.js"></script></head><body><div id="container"><h1 class="text-center">Functorial Blog</h1><p class="lead text-center">A blog about functional programming</p><p class="text-center"><a href="../index.html">Home</a></p></div><section class="dark"><div class="container"><h2>Stackless Coroutines in PureScript</h2><p><small>by Phil Freeman on 2015/07/31</small></p><p>In this post, I&#39;m going to describe how a neat trick known to the PureScript community allows us to write a
stack-safe implementation of the <em>free monad transformer</em> for a functor.</p>
<h2>Free Monads and Coroutines</h2>
<p>Free monads are a useful tool in Haskell (and Scala, and PureScript, and other languages) when you want to separate
the specification of a <code>Monad</code> from its interpretation. We use a <code>Functor</code> to describe the terms we want to use, and
construct a <code>Monad</code> for free, which can be used to combine those terms.</p>
<p>Free monads can be used to construct models of <em>coroutines</em>, by using the base functor to specify the operations which
can take place when a coroutine suspends:</p>
<pre class="haskell"><code>data Emit a = Emit o a

type Producer = Free Emit

emit :: o -&gt; Generator Unit
emit o = liftF (Emit o unit)

emit3 :: Producer Int
emit3 = do
  emit 1
  emit 2
  emit 3
</code></pre>
<p>We can vary the underlying <code>Functor</code> to construct coroutines which produce values, consume values, fork child coroutines,
join coroutines, and combinations of these.</p>
<p>This is described in [1], where free monad <em>transformers</em> are used to build a library of composable coroutines and combinators
which support effects in some base monad. If you haven&#39;t read this article yet, take some time to read it.</p>
<h2>Free Monads in Scala</h2>
<p>Implementing free monads in languages like Scala and PureScript is tricky. A naive translation of the Haskell implementation
works well for small computations, but we quickly run into the problem of <em>stack overflow</em> when running larger computations
in free monads. Techniques such as monadic recursion become unusable.</p>
<p>Fortunately, the solution has been known to the Scala community for some time. [2] describes how to defer monadic binds in the
free monad, by capturing binds as a data structure. We can then write a tail recursive function to interpret this data structure of
binds, giving a free monad implementation which supports deep recursion.</p>
<p>This technique is also used in the <code>purescript-free</code> library, where the data constructor capturing the bind is named <code>Gosub</code>:</p>
<pre class="haskell"><code>newtype GosubF f a b = GosubF (Unit -&gt; Free f b) (b -&gt; Free f a)

data Free f a = Pure a
              | Free (f (Free f a))
              | Gosub (Exists (GosubF f a))
</code></pre>
<p>Here, we add the <code>Gosub</code> constructor which directly captures the arguments to a monadic bind, existentially hiding the return type <code>b</code>
of the inner action.</p>
<p>By translating the implementation in the paper, <code>purescript-free</code> builds a stack-safe free monad implementation for PureScript, which
has been used to construct several useful libraries.</p>
<p>However, in [2], when discussing the extension to a monad transformer, it is correctly observed that:</p>
<pre><code>In the present implementation in Scala, it&#39;s necessary to forego the parameterization on an additional monad, in order to
preserve tail call elimination. Instead of being written as a monad transformer itself, Free could be transformed by a monad 
transformer for the same effect.
</code></pre>
<p>That is, it&#39;s not clear how to extend the <code>Gosub</code> trick to the free monad <em>transformer</em> if we want to be able to transform an arbitrary monad.</p>
<p>Additionally, the approach of putting a monad transformer <em>outside</em> <code>Free</code> is not as useful as we&#39;d like if we want to be able to use free monad
transformers in PureScript to describe coroutines, since we often want the <code>Eff</code> monad at the bottom of the stack, and there is no <code>EffT</code>
transformer!</p>
<p>Fortunately, all is not lost. A neat trick known to the PureScript community saves the day.</p>
<h2>Tail Recursive Monads</h2>
<p>The PureScript compiler performs tail-call elimination for self-recursive functions, so that a function like</p>
<pre class="haskell"><code>pow :: Int -&gt; Int -&gt; Int
pow n p = go { accum: 1, power: p }
  where
  go { accum: acc, power: 0 } = acc
  go { accum: acc, power: p } = go { accum: acc * n, power: p - 1 }
</code></pre>
<p>gets compiled into an efficient <code>while</code> loop.</p>
<p>However, we do not get the same benefit when using monadic recursion:</p>
<pre class="haskell"><code>powWriter :: Int -&gt; Int -&gt; Writer Product Unit
powWriter n = go
  where
  go 0 = return unit
  go m = do
    tell n
    go (m - 1)
</code></pre>
<p>However, we can refactor the original function to isolate the recursive function call:</p>
<pre class="haskell"><code>pow :: Int -&gt; Int -&gt; Int
pow n p = tailRec go { accum: 1, power: p }
  where
  go :: _ -&gt; Either _ Number
  go { accum: acc, power: 0 } = Right acc
  go { accum: acc, power: p } = Left { accum: acc * n, power: p - 1 }
</code></pre>
<p>where the <code>tailRec</code> function is defined in the <code>Control.Monad.Rec.Class</code> module, with type:</p>
<pre class="haskell"><code>tailRec :: forall a b. (a -&gt; Either a b) -&gt; a -&gt; b
</code></pre>
<p>In the body of the loop, instead of calling the <code>go</code> function recursively, we return a value using the <code>Left</code> constructor. To break from
the loop, we use the <code>Right</code> constructor.</p>
<p>The type of <code>tailRec</code> can be generalized to several monad transformers from the <code>purescript-transformers</code> library using the
following type class in the <code>purescript-tailrec</code> library:</p>
<pre class="haskell"><code>class (Monad m) &lt;= MonadRec m where
  tailRecM :: forall a b. (a -&gt; m (Either a b)) -&gt; a -&gt; m b
</code></pre>
<p>It turns out that this class of &quot;tail recursive monads&quot; is large enough to be useful, including base monads like <code>Eff</code> and <code>Identity</code>, and
closed under transformers like <code>StateT</code>, <code>ErrorT</code>, <code>WriterT</code> etc. It is also enough to rescue the implementation of <code>FreeT</code>.</p>
<h2>Stack-Safe Free Monad Transformers</h2>
<p>We can steal the <code>Gosub</code> trick from the <code>Free</code> monad implementation and apply it to our proposed <code>FreeT</code>:</p>
<pre class="haskell"><code>data GosubF f m b a = GosubF (Unit -&gt; FreeT f m a) (a -&gt; FreeT f m b)

data FreeT f m a 
  = FreeT (Unit -&gt; m (Either a (f (FreeT f m a)))) 
  | Gosub (Exists (GosubF f m a))
</code></pre>
<p>The instances for <code>Monad</code> and friends generalize nicely from <code>Free</code> to <code>FreeT</code>, composing binds by nesting <code>Gosub</code> constructors.
The tricky problem is how to <em>run</em> a computation in a free monad computation.</p>
<p>Instead of allowing interpretation in any monad, we only support interpretation in one of our tail recursive monads. We can reduce
the process of interpreting the computation to a tail recursive function in that monad:</p>
<pre class="haskell"><code>runFreeT :: forall f m a. (Functor f, MonadRec m) =&gt; (forall a. f a -&gt; m a) -&gt; FreeT f m a -&gt; m a
</code></pre>
<p>See the <a href="https://github.com/paf31/purescript-coroutines/blob/4ca466573c581f487745a3c4ff88c30d63fc6c3a/src/Control/Coroutine.purs#L103">implementation of <code>runFreeT</code></a> for more details.</p>
<h2>Stackless Coroutines</h2>
<p>Given a stack-safe implementation of the free monad transformer, it becomes simple to translate the coroutines from [1] into PureScript. Here is
an example of a producer/consumer pair described using two coroutines:</p>
<pre class="haskell"><code>producer :: forall m. (Monad m) =&gt; Producer Int m Unit
producer = go 0
  where
  go i = do emit i
            go (i + 1)
    
consumer :: forall a. (Show a) =&gt; Consumer a (Eff _) Unit
consumer = forever do
  s &lt;- await
  lift (log s)
</code></pre>
<p>Despite the monadic recursion in <code>producer</code>, these coroutines can be connected and run using a constant amount of stack, thanks to the
combination of tricks above:</p>
<pre class="haskell"><code>main = runProcess (producer $$ consumer)
</code></pre>
<p>The <code>purescript-coroutines</code> library supports a handful of combinators for connecting producers, consumers and transformers,
as well as more powerful, generic coroutine machinery taken from [1].</p>
<p>I hope that this library will become the basis of an ecosystem of streaming utility libraries in PureScript. If you&#39;re interested in
contributing, join us on the #purescript Freenode channel to discuss it!</p>
<h2>References</h2>
<ol>
<li><em>Coroutine Pipelines</em>, by Mario Blazevic, in <em>The Monad Reader</em>, <em>Issue 19</em>.</li>
<li><em>Stackless Scala With Free Monads</em>, by Runar Oli Bjarnason.</li>
</ol>
</div></section><div class="container"><p class="text-center text-muted"><small>Copyright Phil Freeman 2010-2015</small></p></div></body></html>